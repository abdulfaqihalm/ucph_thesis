---
title: "result_analysis"
author: "Abdullah Faqih Al Mubarok"
date: "2024-04-03"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r cars}
library(universalmotif)
library(Biostrings)
library(reticulate)
np <- import("numpy")
library(tidyverse)
library(ggplot2)
library(gridExtra)
library(grid)
library(patchwork)  # Ensure this library is loaded for inset_element
library(ggrepel)
library(latex2exp)
library(ggseqlogo)
library(parallel)
library(doMC)
library(foreach)
```

## Including Plots

You can also embed plots, for example:

```{r pressure, echo=FALSE}
seq_list <- list()
for(i in 1:5)
{
  seq_list[[i]] <- Biostrings::readDNAStringSet(paste0("/Users/faqih/Documents/UCPH/Thesis/code/data/double_outputs/motif_fasta_test_SPLIT_",i,".fasta"))
}
seqs <- c(seq_list[[1]],seq_list[[2]],seq_list[[3]],seq_list[[4]],seq_list[[5]])
seq_mat <- as.matrix(seqs)

```

```{r}
freq <- table(as.vector(seq_mat))[c("A","C","G","T")]
nt_freqs <- as.vector(freq)/sum(as.vector(freq))
names(nt_freqs) <- c("A","C","G","U")
```

```{r}
names(nt_freqs) <- c("A","C","G","U")
nt_freqs
```

```{r}
sequences <- list()
for(fold in 1:5)
{
  npz <- np$load(paste0("first_layer_fold_",fold,"_seqs.npz"), allow_pickle = TRUE) # contains "filter_{i}" for each npz
  sequences[[fold]] <- npz 
}
# features_1 <- abind(features_1)
dim(sequences[[2]][["filter_1"]])
dim(sequences[[1]][["filter_2"]])
```

```{r}
motList <- list()
for (fold in 1:5){
  temp <- list()
  for (filter in 1:16){
    dna_ss <- RNAStringSet(sequences[[fold]][[paste0("filter_",filter)]])
    motif <- universalmotif::create_motif(dna_ss,
                              type="PWM",
                              name= paste0("filter_",filter),
                              pseudocount = 1,
                              bkg = nt_freqs[c("A","C","G","U")])
  
    temp[[filter]] <- motif
  }
  motList[[fold]] <- temp
}
length(unlist(motList))
```


```{r}


for (fold in c(1:5)){
  mat_matrix = list()
  for (filter in c(1:16)){
    temp_mat <- convert_type(motList[[fold]][[filter]], 'ICM')@motif
    mat_matrix[[filter]] <- temp_mat
  }
  
  ggseqlogo(mat_matrix)
}

```



```{r}
plot_list <- list() # Initialize an empty list to store ggplot objects

for (fold in 1:5) {
  plots <- list() # Temporary list to store plots for each fold
  for (filter in 1:16) {
    temp_mat <- convert_type(motList[[fold]][[filter]], 'ICM')@motif
    p <- ggseqlogo(temp_mat) + 
      labs(title = paste("Fold", fold, "Filter", filter))
    plots[[filter]] <- p
  }
  # Combine all plots for the current fold
  combined_plot <- do.call(gridExtra::grid.arrange, c(plots, ncol = 4))
  plot_list[[fold]] <- combined_plot
}
```



```{r}
# Searching for the motif
seq_train_list <- list()
seq_test_list <- list()
valid_data_list <- list()
for(fold in 1:5)
{
  seq_train_list[[fold]] <- RNAStringSet(Biostrings::readDNAStringSet(paste0("/Users/faqih/Documents/UCPH/Thesis/code/data/double_outputs/motif_fasta_train_SPLIT_",fold,".fasta")))
  seq_test_list[[fold]] <- RNAStringSet(Biostrings::readDNAStringSet(paste0("/Users/faqih/Documents/UCPH/Thesis/code/data/double_outputs/motif_fasta_test_SPLIT_",fold,".fasta")))
  valid_data_list[[fold]] <- read_csv(paste0("validation_",fold,"th_fold_dual_outputs_m6_info-no_promoter-False_MOTIF.csv"), show_col_types = FALSE)
}
seqs_train <- c(seq_train_list[[1]],seq_train_list[[2]],seq_train_list[[3]],seq_train_list[[4]],seq_train_list[[5]])
seqs_test <- c(seq_test_list[[1]],seq_test_list[[2]],seq_test_list[[3]],seq_test_list[[4]],seq_test_list[[5]])
```

```{r}
valid_data_list

start_slice <- 250
end_slice <- 750
```

```{r}
scan_list = list()
motif_vector_list = list()
for (fold in 1:5){
  # Resulted in overlap motif
  # if using enrich_motifs, not entirched!
  # by default it uses p-value as the threshold. It will use dynamic pvalue which uses default bkg
  scan <-universalmotif::scan_sequences(motList[[fold]],subseq(seq_test_list[[fold]],start = start_slice,end = end_slice),
                                        nthreads=4)
  # to check the enrichment motif with the same params: enrich_motifs(motList[[fold]],subseq(seq_test_list[[fold]],start = start_slice,end = end_slice), nthreads=4, RC = FALSE, no.overlaps=FALSE)
  # the enrichment motif will use the fisher vector of contingency b/w seqList and background by [[num_hits, num_non_hits],[bkg_num_hits, bkg_num_non_hits]] -> H0 there is no relation between hits and experimental (non-background). Actually we could use it to filter further what kind of motifs which we can look at (as.tibble(enrich_coba) |> dplyr::arrange(desc(target.hits)))
  scan_list[[fold]] <- scan
  scan <- as.tibble(scan)
  motif_vector_list[[fold]] <- list()
  for (selected_motif in (unique(scan |> dplyr::pull(motif)))) {
    seqs_id <- c(1:length(seq_test_list[[fold]]))
    motif_seqs <- scan |> 
      dplyr::filter(motif == selected_motif) |> 
      pull(sequence.i)
    motif_vector_list[[fold]][[selected_motif]] <- as.integer(seqs_id %in% motif_seqs )
  }
}


```


```{r}
library(universalmotif)
library(GenomicRanges)
library(ggbio)

coba <- universalmotif::scan_sequences(motList[[fold]],subseq(seq_test_list[[fold]],start = start_slice,end = end_slice),
                                       nthreads=4, return.granges = TRUE)
autoplot(coba, layout = "karyogram", aes(fill = motif, color = motif)) +
theme(
strip.background = element_rect(fill = NA, colour = NA),
panel.background = element_rect(fill = NA, colour = NA)
)
```




```{r}
model_summ_list <- list()
model_summ_df <- dplyr::tibble(
  fold = integer(),
  filter = integer(),
  consensus = character(),
  est_ctrl = numeric(),
  est_OR_ctrl = numeric(),
  est_low_OR_ctrl = numeric(),
  est_high_OR_ctrl = numeric(),
  est_ctrl_pval = numeric(),
  est_case = numeric(),
  est_OR_case = numeric(),
  est_low_OR_case = numeric(),
  est_high_OR_case = numeric(),
  est_case_pval = numeric()
)

for (fold in 1:5){
  model_summ_list[[fold]] <- list()
  for (filter in 1:16){
    temp_df <- valid_data_list[[fold]] |> dplyr::select(c(pred_control, pred_case))
    model <- glm(motif_vector_list[[fold]][[paste0("filter_",filter)]] ~ temp_df$pred_control + temp_df$pred_case, family="binomial")
    model_conf_int <- exp(confint(model))
    summ_model <- summary(model)
    coeff <- summ_model$coefficients
    model_summ_list[[fold]][[filter]] <- summ_model
    model_summ_df <- model_summ_df |> 
      dplyr::add_row(fold = fold, filter = filter,
                     consensus=as.data.frame(motList[[fold]][[filter]])$consensus, 
                     est_ctrl = coeff[2,1],
                     est_OR_ctrl = exp(coeff[2,1]),
                     est_low_OR_ctrl = model_conf_int[2,1],
                     est_high_OR_ctrl = model_conf_int[2,2],
                     est_ctrl_pval = coeff[2,4], 
                     est_case = coeff[3,1], 
                     est_OR_case = exp(coeff[3,1]), 
                     est_low_OR_case =  model_conf_int[3,1],
                     est_high_OR_case = model_conf_int[3,2],
                     est_case_pval = coeff[3,4])
  }
}

head(model_summ_df)
```



```{r}
model_summ_df |> mutate(signf_ctrl = ifelse(est_ctrl_pval < 0.05, "SIGNF", "UNSIGNF"),
                        signf_case = ifelse(est_case_pval < 0.05, "SIGNF", "UNSIGNF"))
```



```{r}


ggplot(data = model_summ_df |> mutate(signf_ctrl = ifelse(est_ctrl_pval < 0.05, "SIGNF", "UNSIGNF"),
                        signf_case = ifelse(est_case_pval < 0.05, "SIGNF", "UNSIGNF")), 
       mapping = aes(x = est_ctrl, y = est_case, label = consensus)) + 
  geom_point(mapping = aes(shape = factor(signf_ctrl), color = factor(signf_case)))+
  geom_hline(yintercept = 0) +
  geom_vline(xintercept = 0) +
  geom_text_repel() + 
  # title("Plot Logit Model Of Motif ") + 
  xlab("est log(ctrl m6A_level OR) effect") +
  ylab("est log(ctrl m6A_level OR) effect") +
  xlim(-15, 15) + 
  ylim(-10, 10) +
  #theme with white background
  theme_bw() +
  theme(
    plot.background = element_blank(),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    panel.border = element_blank()
  ) 


```

```{r}
# Assuming model_summ_df already contains odds_ratio and CI for both control and case
ggplot(data = model_summ_df, aes(x = consensus)) + 
  geom_point(aes(y = est_OR_ctrl, color = "Control"), size = 3) +
  geom_errorbar(aes(ymin = est_low_OR_ctrl, ymax = est_high_OR_ctrl, color = "Control"), width = 0.2) +
  geom_point(aes(y = est_OR_case, color = "Case"), size = 3) +
  geom_errorbar(aes(ymin = est_low_OR_case, ymax = est_high_OR_case, color = "Case"), width = 0.2) +
  scale_color_manual(values = c("Control" = "blue", "Case" = "red")) +
  geom_hline(yintercept = 1, linetype = "dashed") +  # OR = 1 line
  coord_trans(y = "log") +  # Log scale for odds ratios
  labs(
    title = "Odds Ratios of Logistic Regression Model",
    x = "",
    y = "Odds Ratio (log scale)",
    color = "Condition"
  ) +
  theme_bw() +
  theme(
    plot.background = element_blank(),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    panel.border = element_blank(),
    legend.position = "bottom"
  ) +
  # geom_text_repel(aes(y = odds_ratio_ctrl, label = consensus), color = "black", size = 3, direction = "y") +
  ylim(c(0.1, 10))  # Adjust as needed based on your data

```



```{r}
hist(scan_list[[fold]]$start + 250 -1)
hist(scan_list[[fold]]$stop + 250 -1)
```


HERE IT IS BASED ON THE OCCURENCE 

```{r}

n_cores <- parallel::detectCores()
doMC::registerDoMC(n_cores-1)

#Check registered DoPar 
foreach::getDoParRegistered() == TRUE 
# foreach::getDoParWorkers() == 6 # In my MBP M1 

fold = 5

start <- proc.time()[[3]]
# Parallel loop to compute increments
scan_list <- foreach(seq_id = 1:length(seq_test_list[[fold]]), 
                     .packages = c("foreach", "tidyverse")) %dopar% {
  # Create a local matrix to store the increment for this iteration
  local_increment <- matrix(0, nrow = filter, ncol = width(seq_test_list[[fold]][1]) )
  rownames(local_increment) <- paste0("filter_",c(1:filter))
  
  for (filter_idx in c(1:filter)){
    filter_at <- paste0("filter_",filter_idx)
    temp <- results |> filter(motif==filter_at, sequence.i==seq_id)
    if (nrow(temp) != 0){
      for(row_temp in c(1:dim(temp)[1])){
        # Calculate start and stop positions
        start_pos <- temp$start[row_temp] + (start_slice - 1)
        stop_pos <- temp$stop[row_temp] + (start_slice - 1)
        
        print(start_pos)
        print(stop_pos)

        # Increment the local matrix for the given motif occurrence
        local_increment[filter_at, start_pos:stop_pos] <- local_increment[filter_at, start_pos:stop_pos] + 1
        
      }
    }
  }
  local_increment
}

# Sum up all increments
# freq_result <- rowsum(increments_list, row.names(increments_list))
elapsed <- proc.time()[[3]] - start

print(paste0("Elapsed time: ", elapsed))


scan_list_reduce <- Reduce(`+`, scan_list) # 16,1001 
```



I think we need to change it such that our data is consist of starting index of motif, nad the y axis is the score find from the scan_motif. Therefore we can find any scoring which is not overlap for the downstream graph!

```{r}
results |> group_by(sequence.i) |> count() |> arrange(desc(n)) |> head()
```







```{r}
# OVERALL PATTERN 
temp_df <- data.frame(x=c(1:1001), y=colSums(scan_list_reduce))
ggplot(temp_df, mapping=aes(x=x, y=y, color="black", fill="gray")) + 
  geom_bar(stat="identity", position="identity", show.legend = FALSE) + 
  xlim(250,750) +
  labs(title = "Overall Pattern Cumulative Sum of Detected Motif",
       x = "Position",
       y = "Cumulative Sum") + 
  theme_minimal()

```

```{r}

filter = 7
temp_df <- data.frame(x=c(-500:500), y=scan_list_reduce[filter,]) #5, 10, 11
temp_mean_df <- data.frame(x=c(-500:500), y=colMeans(scan_list_reduce))
bar <-ggplot() + 
  geom_line(temp_mean_df, mapping=aes(x=x, y=y), color="grey", show.legend = FALSE) + 
  geom_line(temp_df, mapping=aes(x=x, y=y), color="red", show.legend = FALSE) + 
  xlim(-260,240) +
  labs(
       x = "Starting Position of Motif Relative to m6A Site",
       y = "Cumulative Window Hits") + 
  theme_minimal() + 
  #eliminates background, gridlines, and chart border
  theme(
    plot.background = element_blank(),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
  ) 


temp_mat <- universalmotif::convert_type(motList[[fold]][[filter]], 'ICM')@motif
p <- ggseqlogo::ggseqlogo(temp_mat) 

blank <- grid::nullGrob()

# Layout
layout_matrix <- matrix(c(1, 4, 3, 4,2,4), nrow = 3, byrow = TRUE)
gridExtra::grid.arrange(blank, blank, p, bar,  layout_matrix = layout_matrix, 
             widths = c(1, 3), heights = c(2.3, 2, 2.3), top=paste("Fold", fold, "Filter", filter))
```


```{r}
library(patchwork)
filter = 5
temp_df <- data.frame(x=c(1:1001), y=scan_list_reduce[filter,]) #5, 10, 11
temp_mean_df <- data.frame(x=c(1:1001), y=colMeans(scan_list_reduce))
bar <-ggplot() + 
  geom_line(temp_mean_df, mapping=aes(x=x, y=y), color="grey", show.legend = FALSE) + 
  geom_line(temp_df, mapping=aes(x=x, y=y), color="red", show.legend = FALSE) + 
  xlim(260,740) +
  labs(title=paste("Fold", fold, "Filter", filter),
       x = "Starting Position of Motif",
       y = "Cumulative Window Hits") + 
  theme_minimal() + 
  #eliminates background, gridlines, and chart border
  theme(
    plot.background = element_blank(),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
  ) 

temp_mat <- universalmotif::convert_type(motList[[fold]][[filter]], 'ICM')@motif
p <- ggseqlogo::ggseqlogo(temp_mat) 

bar + inset_element(p, 0.7, 0, 1, 0.3)
```


```{r}

for (fold in 1:5) {
  plots <- list() # Temporary list to store plots for each fold
  for (filter in 1:16) {
    temp_mat <- convert_type(motList[[fold]][[filter]], 'ICM')@motif
    p <- ggseqlogo(temp_mat) + 
      labs(title = paste("Fold", fold, "Filter", filter))
    plots[[filter]] <- p
  }
  # Combine all plots for the current fold
  combined_plot <- do.call(gridExtra::grid.arrange, c(plots, ncol = 4))
  plot_list[[fold]] <- combined_plot
}
```



```{r}

plot_list <- list()
for (fold in 5:5) {  # Adjust the range as needed
  plots <- list() # Temporary list to store plots for each fold
  plots_vec <- c()
  for (filter in 1:16) {
    temp_df <- data.frame(x = 1:1001, y = scan_list_reduce[filter,])
    temp_mean_df <- data.frame(x = 1:1001, y = colMeans(scan_list_reduce))

    bar <- ggplot() + 
      geom_line(data = temp_mean_df, aes(x = x, y = y), color = "grey", show.legend = FALSE) +
      geom_line(data = temp_df, aes(x = x, y = y), color = "red", show.legend = FALSE) +
      xlim(260, 740) +
      labs(x = "Position", y = "Cumulative Window Sum") + 
      theme_minimal() +
      theme(plot.background = element_blank(), panel.grid.major = element_blank(), panel.grid.minor = element_blank())

    temp_mat <- universalmotif::convert_type(motList[[fold]][[filter]], 'ICM')@motif
    p <- ggseqlogo::ggseqlogo(temp_mat)
    combined_plot <- bar + patchwork::inset_element(p, left = 0.7, bottom = 0, right = 1, top = 0.3)
    



    blank <- grid::nullGrob()
    
    # Layout
    layout_matrix <- matrix(c(1, 4, 3, 4,2,4), nrow = 3, byrow = TRUE)
    combined_plot <- gridExtra::grid.arrange(blank, blank, p, bar,  layout_matrix = layout_matrix, 
                 widths = c(1, 3), heights = c(2.3, 2, 2.3), top=paste("Fold", fold, "Filter", filter))
    
    # Combine plots directly into a patchwork object
    plots[[filter]] <- combined_plot
    plots_vec <- append(plots_vec, combined_plot)
    print(combined_plot)
  }
  # Use a compatible method to combine all plots in `plots`
  plot_grid <-  ggpubr::ggarrange(plots_vec, common.legend = TRUE)
  plot_list[[fold]] <- plot_grid
}
```



```{r}
plot_list <- list()
for (fold in 5:5) {
  plot_grid <- list()  # Initialize to store combined ggplot objects
  for (filter in 1:16) {
    # Generate each plot
    temp_df <- data.frame(x = 1:1001, y = scan_list_reduce[filter,])
    temp_mean_df <- data.frame(x = 1:1001, y = colMeans(scan_list_reduce))

    bar <- ggplot() + 
      geom_line(data = temp_mean_df, aes(x = x, y = y), color = "grey") +
      geom_line(data = temp_df, aes(x = x, y = y), color = "red") +
      xlim(260, 740) +
      labs(x = "Position", y = "Cumulative Window Sum") +
      theme_minimal() +
      theme(
        plot.background = element_blank(),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        plot.margin = margin(5, 5, 5, 5, "pt")  # Adjust margins as needed
      )

    temp_mat <- universalmotif::convert_type(motList[[fold]][[filter]], 'ICM')@motif
    p <- ggseqlogo::ggseqlogo(temp_mat)
    combined_plot <- bar + inset_element(p, left = 0.7, bottom = 0, right = 1, top = 0.3)

    # Add to the cumulative plot object
    if (is.null(plot_grid)) {
      plot_grid <- combined_plot
    } else {
      plot_grid <- plot_grid + combined_plot
    }
  }
  
  # Define the layout and include spacers if needed
  plot_grid <- plot_grid + 
    plot_layout(ncol = 4, nrow = 4, widths=8, heights=4)  # Ensuring layout fits all plots
  plot_list[[fold]] <- plot_grid
}
```

```{r}
n_cores <- parallel::detectCores()
doMC::registerDoMC(n_cores-1)

#Check registered DoPar 
foreach::getDoParRegistered() == TRUE 
# foreach::getDoParWorkers() == 6 # In my MBP M1 

fold = 5

start <- proc.time()[[3]]
# Parallel loop to compute increments
scan_list_score <- foreach(seq_id = 1:length(seq_test_list[[fold]]), 
                     .packages = c("foreach", "tidyverse")) %dopar% {
  # Create a local matrix to store the increment for this iteration
  local_increment_score <- matrix(0, nrow = filter, ncol = width(seq_test_list[[fold]][1]) )
  rownames(local_increment_score) <- paste0("filter_",c(1:filter))
  
  for (filter_idx in c(1:filter)){
    filter_at <- paste0("filter_",filter_idx)
    temp <- as.tibble(scan_list[[fold]]) |> filter(motif==filter_at, sequence.i==seq_id)
    if (nrow(temp) != 0){
      for(row_temp in c(1:dim(temp)[1])){
        # Calculate start positions
        start_pos <- temp$start[row_temp] + (start_slice - 1)
        
        print(start_pos)
        # Increment the local matrix for the given motif score
        local_increment_score[filter_at, start_pos:start_pos] <- local_increment_score[filter_at, start_pos:start_pos] + temp$score[row_temp] 
        
      }
    }
  }
  local_increment_score
}

# Sum up all increments
# freq_result <- rowsum(increments_list, row.names(increments_list))
elapsed <- proc.time()[[3]] - start

print(paste0("Elapsed time: ", elapsed))


scan_list_score_reduce <- Reduce(`+`, scan_list_score) # 16,1001 
```

# DRACH: D(A/G/T)R(A/G)CH(A/C/T)
```{r}
plot_motif_dist <- function(scan_list_score_reduce, motList, fold, filter, xlim=10) {
  temp_df <- data.frame(x=c(-500:500), y=scan_list_score_reduce[filter,]) # Fold5: 5(not enrich), 10, 11
  # TOMTOM FOR FOLD 5 https://meme-suite.org/meme//opal-jobs/appTOMTOM_SHORT_5.5.51713708295061807977788/tomtom.html
  
  temp_mean_df <- data.frame(x=c(-500:500), y=colMeans(scan_list_score_reduce))
  bar <-ggplot() + 
    geom_line(temp_mean_df, mapping=aes(x=x, y=y), color="grey", show.legend = FALSE) + 
    geom_line(temp_df, mapping=aes(x=x, y=y), color="red", show.legend = FALSE) + 
    xlim(-xlim,xlim) +
    labs(
         x = "Starting Position of Motif Relative to m6A Site",
         y = "Cumulative Score") + 
    theme_minimal() + 
    #eliminates background, gridlines, and chart border
    theme(
      plot.background = element_blank(),
      panel.grid.major = element_blank(),
      panel.grid.minor = element_blank(),
    ) +
    geom_vline(xintercept = 0, linetype="dotted")
  
  temp_mat <- universalmotif::convert_type(motList[[fold]][[filter]], 'ICM')@motif
  p <- ggseqlogo::ggseqlogo(temp_mat) 
  
  blank <- grid::nullGrob()
  
  # Layout
  layout_matrix <- matrix(c(1, 4, 3, 4,2,4), nrow = 3, byrow = TRUE)
  gridExtra::grid.arrange(blank, blank, p, bar,  layout_matrix = layout_matrix, 
               widths = c(1, 3), heights = c(2.3, 2, 2.3), top=paste("Fold", fold, "Filter", filter))
    
}
```

```{r}
plot_motif_dist(scan_list_score_reduce, motList, fold=5, filter=5, 10)
plot_motif_dist(scan_list_score_reduce, motList, fold=5, filter=10, 10)
plot_motif_dist(scan_list_score_reduce, motList, fold=5, filter=11, 10) # Fold5: 5(not enrich), 10, 11
# TOMTOM FOR FOLD 5 https://meme-suite.org/meme//opal-jobs/appTOMTOM_SHORT_5.5.51713708295061807977788/tomtom.html
```

